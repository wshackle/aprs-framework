/*
 * This software is public domain software, however it is preferred
 * that the following disclaimers be attached.
 * Software Copywrite/Warranty Disclaimer
 * 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain.
 * 
 * This software is experimental. NIST assumes no responsibility whatsoever 
 * for its use by other parties, and makes no guarantees, expressed or 
 * implied, about its quality, reliability, or any other characteristic. 
 * We would appreciate acknowledgement if the software is used. 
 * This software can be redistributed and/or modified freely provided 
 * that any derivative works bear some notice that they are derived from it, 
 * and any modified versions bear some notice that they have been modified.
 * 
 *  See http://www.copyright.gov/title17/92chap1.html#105
 * 
 */
package aprs.framework.pddl.planner;

import aprs.framework.pddl.executor.PddlExecutorJInternalFrame;
import aprs.framework.AprsJFrame;
import aprs.framework.DisplayInterface;
import aprs.framework.PddlAction;
import com.jcraft.jsch.Channel;
import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.UserInfo;
import crcl.ui.misc.MultiLineStringJPanel;
import java.awt.Desktop;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;

/**
 *
 * @author Will Shackleford {@literal <william.shackleford@nist.gov>}
 */
public class PddlPlannerJPanel extends javax.swing.JPanel implements DisplayInterface {

    /**
     * Creates new form PddlPlannerJPanel
     */
    public PddlPlannerJPanel() {
        initComponents();
        jSpinnerMaxLines.setValue(250);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jTextFieldPlannerProgramExecutable = new javax.swing.JTextField();
        jButtonPlannerProgramExecutableBrowse = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldPddlDomainFile = new javax.swing.JTextField();
        jButtonPddlDomainBrowse = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jTextFieldPddlProblem = new javax.swing.JTextField();
        jButtonPddlProblemBrowse = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        jTextFieldAdditionalArgs = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaOutput = new javax.swing.JTextArea();
        jButtonRunOnce = new javax.swing.JButton();
        jButtonStop = new javax.swing.JButton();
        jButtonPddlDomainEdit = new javax.swing.JButton();
        jButtonPddlProblemEdit = new javax.swing.JButton();
        jCheckBoxSsh = new javax.swing.JCheckBox();
        jLabel6 = new javax.swing.JLabel();
        jTextFieldSshUser = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        jPasswordFieldSshPass = new javax.swing.JPasswordField();
        jLabel8 = new javax.swing.JLabel();
        jTextFieldHost = new javax.swing.JTextField();
        jSpinnerMaxLines = new javax.swing.JSpinner();
        jCheckBoxPauseOutput = new javax.swing.JCheckBox();
        jButtonClear = new javax.swing.JButton();

        jLabel1.setText("Planner Program Executable:");

        jTextFieldPlannerProgramExecutable.setText("popf3-clp");

        jButtonPlannerProgramExecutableBrowse.setText("Browse");
        jButtonPlannerProgramExecutableBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPlannerProgramExecutableBrowseActionPerformed(evt);
            }
        });

        jLabel2.setText("PDDL Domain File");

        jTextFieldPddlDomainFile.setText("domain-kitting.pddl");
        jTextFieldPddlDomainFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextFieldPddlDomainFileActionPerformed(evt);
            }
        });

        jButtonPddlDomainBrowse.setText("Browse");
        jButtonPddlDomainBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlDomainBrowseActionPerformed(evt);
            }
        });

        jLabel3.setText("PDDL Problem File");

        jTextFieldPddlProblem.setText("problem-a2b1c1.pddl");

        jButtonPddlProblemBrowse.setText("Browse");
        jButtonPddlProblemBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlProblemBrowseActionPerformed(evt);
            }
        });

        jLabel4.setText("Additional Arguments:");

        jTextFieldAdditionalArgs.setText("-I -n");

        jLabel5.setText("Output");

        jTextAreaOutput.setColumns(20);
        jTextAreaOutput.setRows(5);
        jScrollPane1.setViewportView(jTextAreaOutput);

        jButtonRunOnce.setText("Run Once");
        jButtonRunOnce.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRunOnceActionPerformed(evt);
            }
        });

        jButtonStop.setText("Stop");
        jButtonStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonStopActionPerformed(evt);
            }
        });

        jButtonPddlDomainEdit.setText("View/Edit");
        jButtonPddlDomainEdit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlDomainEditActionPerformed(evt);
            }
        });

        jButtonPddlProblemEdit.setText("View/Edit");
        jButtonPddlProblemEdit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlProblemEditActionPerformed(evt);
            }
        });

        jCheckBoxSsh.setText("SSH");
        jCheckBoxSsh.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxSshActionPerformed(evt);
            }
        });

        jLabel6.setText("User:");

        jTextFieldSshUser.setEditable(false);
        jTextFieldSshUser.setText("user ");
        jTextFieldSshUser.setEnabled(false);

        jLabel7.setText("Password:");

        jPasswordFieldSshPass.setEditable(false);
        jPasswordFieldSshPass.setText("jPasswordField1");
        jPasswordFieldSshPass.setEnabled(false);

        jLabel8.setText("Host:");

        jTextFieldHost.setEditable(false);
        jTextFieldHost.setText("localhost");
        jTextFieldHost.setEnabled(false);

        jCheckBoxPauseOutput.setText("Pause");

        jButtonClear.setText("Clear");
        jButtonClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jTextFieldAdditionalArgs)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jTextFieldPddlProblem)
                            .addComponent(jTextFieldPddlDomainFile, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextFieldPlannerProgramExecutable))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jButtonPddlProblemBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButtonPddlProblemEdit))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                    .addComponent(jButtonPddlDomainBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButtonPddlDomainEdit)))
                            .addComponent(jButtonPlannerProgramExecutableBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 179, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSpinnerMaxLines, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxPauseOutput)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButtonClear)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonStop)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonRunOnce))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2)
                            .addComponent(jLabel3)
                            .addComponent(jLabel4))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jCheckBoxSsh)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldSshUser, javax.swing.GroupLayout.DEFAULT_SIZE, 131, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPasswordFieldSshPass, javax.swing.GroupLayout.DEFAULT_SIZE, 116, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel8)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldHost, javax.swing.GroupLayout.DEFAULT_SIZE, 163, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldPlannerProgramExecutable, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonPlannerProgramExecutableBrowse))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldPddlDomainFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonPddlDomainBrowse)
                    .addComponent(jButtonPddlDomainEdit))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldPddlProblem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonPddlProblemBrowse)
                    .addComponent(jButtonPddlProblemEdit))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldAdditionalArgs, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBoxSsh)
                    .addComponent(jLabel6)
                    .addComponent(jTextFieldSshUser, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel8)
                    .addComponent(jTextFieldHost, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel7)
                    .addComponent(jPasswordFieldSshPass, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonRunOnce)
                    .addComponent(jButtonStop)
                    .addComponent(jLabel5)
                    .addComponent(jSpinnerMaxLines, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jCheckBoxPauseOutput)
                    .addComponent(jButtonClear))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 147, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    public void browseProgramExecutable() throws IOException {
        JFileChooser chooser = new JFileChooser(new File(jTextFieldPlannerProgramExecutable.getText()).getParent());
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File f = chooser.getSelectedFile();
            jTextFieldPlannerProgramExecutable.setText(f.getCanonicalPath());
            saveProperties();
        }
    }

    public void browsePddlDomain() throws IOException {
        JFileChooser chooser = new JFileChooser(new File(jTextFieldPddlDomainFile.getText()).getParent());
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File f = chooser.getSelectedFile();
            jTextFieldPddlDomainFile.setText(f.getCanonicalPath());
            saveProperties();
        }
    }

    public void browsePddlProblem() throws IOException {
        JFileChooser chooser = new JFileChooser(new File(jTextFieldPddlProblem.getText()).getParent());
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File f = chooser.getSelectedFile();
            jTextFieldPddlProblem.setText(f.getCanonicalPath());
            saveProperties();
        }
    }

    private File propertiesFile = null;

    /**
     * Get the value of propertiesFile
     *
     * @return the value of propertiesFile
     */
    public File getPropertiesFile() {
        return propertiesFile;
    }

    /**
     * Set the value of propertiesFile
     *
     * @param propertiesFile new value of propertiesFile
     */
    public void setPropertiesFile(File propertiesFile) {
        this.propertiesFile = propertiesFile;
    }

    public void loadProperties() throws IOException {
        if (null == propertiesFile) {
            throw new IllegalStateException("propertiesFile not set");
        }
        if (propertiesFile.exists()) {
            Properties props = new Properties();
            try (FileReader fr = new FileReader(propertiesFile)) {
                props.load(fr);
            }
            String executable = props.getProperty(PROGRAM_EXECUTABLE);
            if (null != executable) {
                jTextFieldPlannerProgramExecutable.setText(executable);
            }
            String domain = props.getProperty(PDDL_DOMAIN);
            if (null != domain) {
                jTextFieldPddlDomainFile.setText(domain);
            }
            String problem = props.getProperty(PDDL_PROBLEM);
            if (null != problem) {
                jTextFieldPddlProblem.setText(problem);
            }
            String useSsh = props.getProperty(PDDL_PLANNER_SSH);
            if (null != useSsh) {
                jCheckBoxSsh.setSelected(Boolean.valueOf(useSsh));
                boolean b = jCheckBoxSsh.isSelected();
                jTextFieldSshUser.setEditable(b);
                jTextFieldSshUser.setEnabled(b);
                jPasswordFieldSshPass.setEditable(b);
                jPasswordFieldSshPass.setEnabled(b);
                jTextFieldHost.setEditable(b);
                jTextFieldHost.setEnabled(b);
            }
            String host = props.getProperty(PDDL_PLANNER_HOST);
            if (null != host) {
                jTextFieldHost.setText(host);
            }
//        String output = props.getProperty(PDDLOUTPUT);
//        if (null != output) {
//            jTextFieldPddlOutputActions.setText(output);
//        }
            String addargs = props.getProperty(PDDL_ADD_ARGS);
            if (null != addargs) {
                jTextFieldAdditionalArgs.setText(addargs);
            }
        }
    }

    private static final String PROGRAM_EXECUTABLE = "program.executable";
    private static final String PDDL_ADD_ARGS = "pddl.addargs";
    private static final String PDDL_PROBLEM = "pddl.problem";
    private static final String PDDL_DOMAIN = "pddl.domain";
    private static final String PDDL_PLANNER_SSH = "pddl.planner.ssh";
    private static final String PDDL_PLANNER_HOST = "pddl.planner.host";


    private void jButtonPlannerProgramExecutableBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPlannerProgramExecutableBrowseActionPerformed
        try {
            browseProgramExecutable();
        } catch (IOException ex) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jButtonPlannerProgramExecutableBrowseActionPerformed

    private void jTextFieldPddlDomainFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextFieldPddlDomainFileActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextFieldPddlDomainFileActionPerformed

    private void jButtonPddlDomainBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlDomainBrowseActionPerformed
        try {
            browsePddlDomain();
        } catch (IOException ex) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jButtonPddlDomainBrowseActionPerformed

    private void jButtonPddlProblemBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlProblemBrowseActionPerformed
        try {
            browsePddlProblem();
        } catch (IOException ex) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jButtonPddlProblemBrowseActionPerformed

    private void jButtonRunOnceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRunOnceActionPerformed
        try {
            runPddlPlannerOnce();
            if (null != actionsToCrclJInternalFrame1) {
                actionsToCrclJInternalFrame1.setLoadEnabled(false);
            }
        } catch (IOException ex) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jButtonRunOnceActionPerformed

    private void jButtonStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonStopActionPerformed
        this.closePddlProcess();
    }//GEN-LAST:event_jButtonStopActionPerformed

    private void jButtonPddlProblemEditActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlProblemEditActionPerformed
        try {
            Desktop.getDesktop().open(new File(jTextFieldPddlProblem.getText()));
        } catch (IOException ex) {
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jButtonPddlProblemEditActionPerformed

    private void jButtonPddlDomainEditActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlDomainEditActionPerformed
        try {
            Desktop.getDesktop().open(new File(jTextFieldPddlDomainFile.getText()));
        } catch (IOException ex) {
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_jButtonPddlDomainEditActionPerformed

    private void jCheckBoxSshActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxSshActionPerformed
        boolean useSsh = jCheckBoxSsh.isSelected();
        jTextFieldSshUser.setEditable(useSsh);
        jTextFieldSshUser.setEnabled(useSsh);
        jPasswordFieldSshPass.setEditable(useSsh);
        jPasswordFieldSshPass.setEnabled(useSsh);
        jTextFieldHost.setEditable(useSsh);
        jTextFieldHost.setEnabled(useSsh);
    }//GEN-LAST:event_jCheckBoxSshActionPerformed

    private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
       jTextAreaOutput.setText("");
    }//GEN-LAST:event_jButtonClearActionPerformed

    private ExecutorService executor = Executors.newCachedThreadPool();

    /**
     * Get the value of executor
     *
     * @return the value of executor
     */
    public ExecutorService getExecutor() {
        return executor;
    }

    /**
     * Set the value of executor
     *
     * @param executor new value of executor
     */
    public void setExecutor(ExecutorService executor) {
        this.executor = executor;
    }

    private PddlExecutorJInternalFrame actionsToCrclJInternalFrame1 = null;

    public PddlExecutorJInternalFrame getActionsToCrclJInternalFrame1() {
        return actionsToCrclJInternalFrame1;
    }

    public void setActionsToCrclJInternalFrame1(PddlExecutorJInternalFrame actionsToCrclJInternalFrame1) {
        this.actionsToCrclJInternalFrame1 = actionsToCrclJInternalFrame1;
    }

    public List<PddlAction> getActionsList() {
        if (null != actionsToCrclJInternalFrame1) {
            return actionsToCrclJInternalFrame1.getActionsList();
        }
        throw new IllegalStateException("actionsToCrclJInternalFrame not set");
    }

    public void setActionsList(List<PddlAction> actionsList) {
        if (null != actionsToCrclJInternalFrame1) {
            actionsToCrclJInternalFrame1.setActionsList(actionsList);
        }
    }

    private void addAction(PddlAction action) {
        if (null != actionsToCrclJInternalFrame1) {
            this.actionsToCrclJInternalFrame1.addAction(action);
        }
    }

    private void processActions() {
        if (null != actionsToCrclJInternalFrame1) {
            this.actionsToCrclJInternalFrame1.processActions();
        }
    }
    private Process pddlProcess = null;
    private InputStream pddlInputStream = null;
    private InputStream pddlErrorStream = null;
    private Future<?> ppdlInputStreamFuture = null;
    private Future<?> ppdlErrorStreamFuture = null;

//    public static void main(String[] arg) {
//        if (arg.length != 2) {
//            System.err.println("usage: java ScpTo file1 user@remotehost:file2");
//            System.exit(-1);
//        }
//
//        try {
//
//            String lfile = arg[0];
//            String user = arg[1].substring(0, arg[1].indexOf('@'));
//            arg[1] = arg[1].substring(arg[1].indexOf('@') + 1);
//            String host = arg[1].substring(0, arg[1].indexOf(':'));
//            String rfile = arg[1].substring(arg[1].indexOf(':') + 1);
//
//            JSch jsch = new JSch();
//            scp(jsch, user, host, rfile, lfile);
//
//            System.exit(0);
//        } catch (Exception e) {
//            System.out.println(e);
//            try {
//                if (fis != null) {
//                    fis.close();
//                }
//            } catch (Exception ee) {
//            }
//        }
//    }
    private UserInfo sshUserInfo = new UserInfo() {
        @Override
        public String getPassphrase() {
            return null;
        }

        @Override
        public String getPassword() {
            String p = new String(jPasswordFieldSshPass.getPassword());
            return p;
        }

        @Override
        public boolean promptPassword(String string) {
            return true;
//                System.out.println(string);
//                return JOptionPane.showConfirmDialog(PddlPlannerJPanel.this, string) == JOptionPane.YES_OPTION;
        }

        @Override
        public boolean promptPassphrase(String string) {
            return false;
//                System.out.println(string);
//                return JOptionPane.showConfirmDialog(PddlPlannerJPanel.this, string) == JOptionPane.YES_OPTION;
        }

        @Override
        public boolean promptYesNo(String string) {
            System.out.println(string);
            return JOptionPane.showConfirmDialog(PddlPlannerJPanel.this, string) == JOptionPane.YES_OPTION;
        }

        @Override
        public void showMessage(String string) {
            System.out.println(string);
//                JOptionPane.showMessageDialog(PddlPlannerJPanel.this, string);
            MultiLineStringJPanel.showText(string);
        }
    };

    private void sshExec(Session session, String command) throws JSchException, IOException, InterruptedException, ExecutionException {
        printMessage("Excuting remote command \"" + command + "\" ...");
        Channel channel = session.openChannel("exec");
        ((ChannelExec) channel).setCommand(command);

        // X Forwarding
        // channel.setXForwarding(true);
        //channel.setInputStream(System.in);
        channel.setInputStream(null);

        //channel.setOutputStream(System.out);
        //FileOutputStream fos=new FileOutputStream("/tmp/stderr");
        //((ChannelExec)channel).setErrStream(fos);
        ((ChannelExec) channel).setErrStream(System.err);

        InputStream in = channel.getInputStream();

        channel.connect();

        pddlInputStream = in;
        pddlErrorStream = null;
        setupOutputHandlers();
        ppdlInputStreamFuture.get();
        channel.disconnect();
//        byte[] tmp = new byte[1024];
//        while (true) {
//            while (in.available() > 0) {
//                int i = in.read(tmp, 0, 1024);
//                if (i < 0) {
//                    break;
//                }
//                System.out.print(new String(tmp, 0, i));
//            }
//            if (channel.isClosed()) {
//                if (in.available() > 0) {
//                    continue;
//                }
//                System.out.println("exit-status: " + channel.getExitStatus());
//                break;
//            }
//            try {
//                Thread.sleep(1000);
//            } catch (Exception ee) {
//            }
//        }
        printMessage("Finished remote command \"" + command + "\".");
    }

    private boolean lastMessageBlank = false;
    
    List<String> logLines = new ArrayList<>();

    private void appendLine(String l) {
        int maxLines = 100;
        try {
            maxLines = (int) jSpinnerMaxLines.getValue();
            if(maxLines < 1) {
                jSpinnerMaxLines.setValue(1);
                maxLines = 1;
            }
        } catch (Exception e) {
        }
        if (logLines.size() < maxLines) {
            addLogLine(l);
            if (!jCheckBoxPauseOutput.isSelected()) {
                jTextAreaOutput.append(l);
            }
        } else {
            while (logLines.size() >= maxLines) {
                logLines.remove(0);
            }
            addLogLine(l);
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < logLines.size(); i++) {
                sb.append(logLines.get(i));
            }
            if (!jCheckBoxPauseOutput.isSelected()) {
                jTextAreaOutput.setText(sb.toString());
            }
        }
        if (!jCheckBoxPauseOutput.isSelected()) {
            jTextAreaOutput.setCaretPosition(jTextAreaOutput.getText().length() - 1);
        }
    }

    private void addLogLine(String l) {
        if (logLines.size() > 0) {
            String lastLine = logLines.get(logLines.size() - 1);
            if (lastLine.endsWith("\n")) {
                logLines.add(l);
            } else {
                logLines.set(logLines.size() - 1, lastLine + l);
            }
        } else {
            logLines.add(l);
        }
    }

    public void appendText(String text) {
        String txt2 = text.replace("\r\n", "\n");
        String lines[] = txt2.split("\n");
        if (lines.length <= 1 || (lines.length == 2) && lines[1].length() < 1) {
            appendLine(txt2);
        } else {
            for (int i = 0; i < lines.length; i++) {
                String line = lines[i];
                if (i < lines.length - 1 || txt2.endsWith("\n")) {
                    appendLine(line + System.lineSeparator());
                } else {
                    appendLine(line);
                }
            }
        }
    }
    private void printMessage(String msg) {
        boolean msgIsBlank = msg.trim().length()<1;
        if(!msgIsBlank || !lastMessageBlank) {
            System.out.println(msg);
            appendText(msg);
        }
        lastMessageBlank = msgIsBlank;
    }

    private void scp(Session session, String host, String rfile, String lfile) throws FileNotFoundException, JSchException, IOException, Exception {
        FileInputStream fis = null;
        printMessage("Copying local file \"" + lfile + "\" to remote host " + host + " as remote file \"" + rfile + "\" ...");
        boolean ptimestamp = false;
        // exec 'scp -t rfile' remotely
        String command = "scp " + (ptimestamp ? "-p" : "") + " -t " + rfile;
        Channel channel = session.openChannel("exec");
        ((ChannelExec) channel).setCommand(command);
        // get I/O streams for remote scp
        OutputStream out = channel.getOutputStream();
        InputStream in = channel.getInputStream();
        channel.connect();
        if (checkAck(in) != 0) {
            System.exit(0);
        }
        File _lfile = new File(lfile);
        if (ptimestamp) {
            command = "T " + (_lfile.lastModified() / 1000) + " 0";
            // The access time should be sent here,
            // but it is not accessible with JavaAPI ;-<
            command += (" " + (_lfile.lastModified() / 1000) + " 0\n");
            out.write(command.getBytes());
            out.flush();
            if (checkAck(in) != 0) {
                System.exit(0);
            }
        }
        // send "C0644 filesize filename", where filename should not include '/'
        long filesize = _lfile.length();
        command = "C0644 " + filesize + " ";
        if (lfile.lastIndexOf('/') > 0) {
            command += lfile.substring(lfile.lastIndexOf('/') + 1);
        } else {
            command += lfile;
        }
        command += "\n";
        out.write(command.getBytes());
        out.flush();
        if (checkAck(in) != 0) {
            System.exit(0);
        }
        // send a content of lfile
        fis = new FileInputStream(lfile);
        byte[] buf = new byte[1024];
        while (true) {
            int len = fis.read(buf, 0, buf.length);
            if (len <= 0) {
                break;
            }
            out.write(buf, 0, len); //out.flush();
        }
        fis.close();
        fis = null;
        // send '\0'
        buf[0] = 0;
        out.write(buf, 0, 1);
        out.flush();
        if (checkAck(in) != 0) {
            System.exit(0);
        }
        out.close();
        channel.disconnect();
        printMessage("Finished copy of local file \"" + lfile + "\" to remote host " + host + " as remote file \"" + rfile + "\".");
    }

    static int checkAck(InputStream in) throws IOException, Exception {
        int b = in.read();
        // b may be 0 for success,
        //          1 for error,
        //          2 for fatal error,
        //          -1
        if (b == 0) {
            return b;
        }
        if (b == -1) {
            throw new Exception("Ssh checkAck() returned: " + b);
        }

        if (b == 1 || b == 2) {
            StringBuffer sb = new StringBuffer();
            int c;
            do {
                c = in.read();
                sb.append((char) c);
            } while (c != '\n');
            if (b == 1) { // error
                System.out.print(sb.toString());
                throw new Exception("Ssh checkAck() returned  error code. b=" + b);
            }
            if (b == 2) { // fatal error
                System.out.print(sb.toString());
                throw new Exception("Ssh checkAck() returned fatal error code. b=" + b);
            }
        }
        return b;
    }

//    public static class MyUserInfo implements UserInfo, UIKeyboardInteractive {
//
//        public String getPassword() {
//            return passwd;
//        }
//
//        public boolean promptYesNo(String str) {
//            Object[] options = {"yes", "no"};
//            int foo = JOptionPane.showOptionDialog(null,
//                    str,
//                    "Warning",
//                    JOptionPane.DEFAULT_OPTION,
//                    JOptionPane.WARNING_MESSAGE,
//                    null, options, options[0]);
//            return foo == 0;
//        }
//
//        String passwd;
//        JTextField passwordField = (JTextField) new JPasswordField(20);
//
//        public String getPassphrase() {
//            return null;
//        }
//
//        public boolean promptPassphrase(String message) {
//            return true;
//        }
//
//        public boolean promptPassword(String message) {
//            Object[] ob = {passwordField};
//            int result
//                    = JOptionPane.showConfirmDialog(null, ob, message,
//                            JOptionPane.OK_CANCEL_OPTION);
//            if (result == JOptionPane.OK_OPTION) {
//                passwd = passwordField.getText();
//                return true;
//            } else {
//                return false;
//            }
//        }
//
//        public void showMessage(String message) {
//            JOptionPane.showMessageDialog(null, message);
//        }
//        final GridBagConstraints gbc
//                = new GridBagConstraints(0, 0, 1, 1, 1, 1,
//                        GridBagConstraints.NORTHWEST,
//                        GridBagConstraints.NONE,
//                        new Insets(0, 0, 0, 0), 0, 0);
//        private Container panel;
//
//        public String[] promptKeyboardInteractive(String destination,
//                String name,
//                String instruction,
//                String[] prompt,
//                boolean[] echo) {
//            panel = new JPanel();
//            panel.setLayout(new GridBagLayout());
//
//            gbc.weightx = 1.0;
//            gbc.gridwidth = GridBagConstraints.REMAINDER;
//            gbc.gridx = 0;
//            panel.add(new JLabel(instruction), gbc);
//            gbc.gridy++;
//
//            gbc.gridwidth = GridBagConstraints.RELATIVE;
//
//            JTextField[] texts = new JTextField[prompt.length];
//            for (int i = 0; i < prompt.length; i++) {
//                gbc.fill = GridBagConstraints.NONE;
//                gbc.gridx = 0;
//                gbc.weightx = 1;
//                panel.add(new JLabel(prompt[i]), gbc);
//
//                gbc.gridx = 1;
//                gbc.fill = GridBagConstraints.HORIZONTAL;
//                gbc.weighty = 1;
//                if (echo[i]) {
//                    texts[i] = new JTextField(20);
//                } else {
//                    texts[i] = new JPasswordField(20);
//                }
//                panel.add(texts[i], gbc);
//                gbc.gridy++;
//            }
//
//            if (JOptionPane.showConfirmDialog(null, panel,
//                    destination + ": " + name,
//                    JOptionPane.OK_CANCEL_OPTION,
//                    JOptionPane.QUESTION_MESSAGE)
//                    == JOptionPane.OK_OPTION) {
//                String[] response = new String[prompt.length];
//                for (int i = 0; i < prompt.length; i++) {
//                    response[i] = texts[i].getText();
//                }
//                return response;
//            } else {
//                return null;  // cancel
//            }
//        }
//    }
    private JSch jsch = null;
    private Session session = null;

    private void runPddlPlannerOnceSsh() {
        try {
            if (null == jsch) {
                jsch = new JSch();
            }
            if (null == session) {
                session = jsch.getSession(jTextFieldSshUser.getText(), jTextFieldHost.getText(), 22);
                // username and password will be given via UserInfo interface.
//        UserInfo ui = new MyUserInfo();
                session.setUserInfo(sshUserInfo);
                session.connect();
            }
            long t = System.currentTimeMillis();
            String remoteDomainFile = "/tmp/domain_" + t + ".pddl";
            String remoteProblemFile = "/tmp/problem_" + t + ".pddl";
            scp(session, jTextFieldHost.getText(), remoteDomainFile, jTextFieldPddlDomainFile.getText());
            scp(session, jTextFieldHost.getText(), remoteProblemFile, jTextFieldPddlProblem.getText());
            sshExec(session, jTextFieldPlannerProgramExecutable.getText() + " " + jTextFieldAdditionalArgs.getText() + " " + remoteDomainFile + " " + remoteProblemFile);
        } catch (Exception ex) {
            printMessage("runPddlPlannerOnceSsh failed with "+ex);
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, null, ex);
        } 
    }

    public void runPddlPlannerOnce() throws IOException {
        this.setActionsList(new ArrayList<>());
        if (this.jCheckBoxSsh.isSelected()) {
            runPddlPlannerOnceSsh();
            return;
        }
        try {
            closePddlProcess();
        } catch (Exception ex) {
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
        List<String> commandList = new ArrayList<>();
        commandList.add(new File(jTextFieldPlannerProgramExecutable.getText()).getCanonicalPath());
        commandList.addAll(Arrays.asList(jTextFieldAdditionalArgs.getText().split("[ \t]+")));
        commandList.add(jTextFieldPddlDomainFile.getText());
        commandList.add(jTextFieldPddlProblem.getText());
        ProcessBuilder pb = new ProcessBuilder(commandList);
        pddlProcess = pb.start();
        pddlInputStream = pddlProcess.getInputStream();
        pddlErrorStream = pddlProcess.getErrorStream();
        jTextAreaOutput.append(commandList.toString() + System.lineSeparator());
        setupOutputHandlers();
    }

    private void setupOutputHandlers() {
        if (null == executor) {
            executor = Executors.newCachedThreadPool();
        }
        if (null != pddlErrorStream) {
            ppdlErrorStreamFuture = executor.submit(new Runnable() {
                @Override
                public void run() {
                    try {
                        BufferedReader br = new BufferedReader(new InputStreamReader(pddlErrorStream));
                        String line = null;
                        while (null != (line = br.readLine()) && !closing && !Thread.currentThread().isInterrupted()) {
                            final String lineToAppend = line;
                            System.out.println("Line from remote error source:"+line);
                            javax.swing.SwingUtilities.invokeLater(new Runnable() {
                                @Override
                                public void run() {
                                    printMessage(lineToAppend + System.lineSeparator());
                                }
                            });
                        }
                    } catch (IOException ex) {
                        Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, ex);
                    }
                }
            });
        }
        ppdlInputStreamFuture = executor.submit(new Runnable() {
            @Override
            public void run() {
                try {
                    BufferedReader br = new BufferedReader(new InputStreamReader(pddlInputStream));
                    String line = null;
                    boolean planFoundFound = false;
                    while (null != (line = br.readLine()) && !closing && !Thread.currentThread().isInterrupted()) {
                        final String lineToAppend = line;
                        System.out.println("Line from remote out source:"+line);
                        javax.swing.SwingUtilities.invokeLater(new Runnable() {
                            @Override
                            public void run() {
                                printMessage(lineToAppend + System.lineSeparator());
                            }
                        });

                        if (planFoundFound) {
                            addAction(PddlAction.parse(lineToAppend));
                        }
                        if (line.contains("; Plan found") || line.contains("Solution Found")) {
                            planFoundFound = true;
                        }
                    }
                    actionsToCrclJInternalFrame1.autoResizeTableColWidthsPddlOutput();
                    processActions();
                } catch (IOException ex) {
                    Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, ex);
                }
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonClear;
    private javax.swing.JButton jButtonPddlDomainBrowse;
    private javax.swing.JButton jButtonPddlDomainEdit;
    private javax.swing.JButton jButtonPddlProblemBrowse;
    private javax.swing.JButton jButtonPddlProblemEdit;
    private javax.swing.JButton jButtonPlannerProgramExecutableBrowse;
    private javax.swing.JButton jButtonRunOnce;
    private javax.swing.JButton jButtonStop;
    private javax.swing.JCheckBox jCheckBoxPauseOutput;
    private javax.swing.JCheckBox jCheckBoxSsh;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPasswordField jPasswordFieldSshPass;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSpinner jSpinnerMaxLines;
    private javax.swing.JTextArea jTextAreaOutput;
    private javax.swing.JTextField jTextFieldAdditionalArgs;
    private javax.swing.JTextField jTextFieldHost;
    private javax.swing.JTextField jTextFieldPddlDomainFile;
    private javax.swing.JTextField jTextFieldPddlProblem;
    private javax.swing.JTextField jTextFieldPlannerProgramExecutable;
    private javax.swing.JTextField jTextFieldSshUser;
    // End of variables declaration//GEN-END:variables

    @Override
    public void saveProperties() throws IOException {
        if (null == propertiesFile) {
            throw new IllegalStateException("propertiesFile not set");
        }
        propertiesFile.getParentFile().mkdirs();
        Map<String, String> propsMap = new HashMap<>();
        propsMap.put(PROGRAM_EXECUTABLE, jTextFieldPlannerProgramExecutable.getText());
        propsMap.put(PDDL_DOMAIN, jTextFieldPddlDomainFile.getText());
        propsMap.put(PDDL_PROBLEM, jTextFieldPddlProblem.getText());
//        propsMap.put(PDDLOUTPUT, jTextFieldPddlOutputActions.getText());
        propsMap.put(PDDL_ADD_ARGS, jTextFieldAdditionalArgs.getText());
        propsMap.put(PDDL_PLANNER_SSH, Boolean.toString(jCheckBoxSsh.isSelected()));
        propsMap.put(PDDL_PLANNER_HOST, jTextFieldHost.getText());
        Properties props = new Properties();
        props.putAll(propsMap);
        try (FileWriter fw = new FileWriter(propertiesFile)) {
            props.store(fw, "");
        }
    }

    private volatile boolean closing = false;

    private void closePddlProcess() {
        boolean orig_closing = closing;
        closing = true;
        try {
            if (null != pddlProcess) {
                pddlProcess.destroyForcibly().waitFor(100, TimeUnit.MILLISECONDS);
                pddlProcess = null;
            }
        } catch (InterruptedException interruptedException) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, interruptedException);
        }
        try {
            if (null != ppdlInputStreamFuture) {
                ppdlInputStreamFuture.cancel(true);
                ppdlInputStreamFuture = null;
            }
        } catch (Exception e) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, e);
        }
        try {
            if (null != ppdlErrorStreamFuture) {
                ppdlErrorStreamFuture.cancel(true);
                ppdlErrorStreamFuture = null;
            }
        } catch (Exception e) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, e);
        }
        try {
            if (null != pddlInputStream) {
                pddlInputStream.close();
                pddlInputStream = null;
            }
        } catch (IOException iOException) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, iOException);
        }
        try {
            if (null != pddlErrorStream) {
                pddlErrorStream.close();
                pddlErrorStream = null;
            }
        } catch (IOException iOException) {
            Logger.getLogger(AprsJFrame.class.getName()).log(Level.SEVERE, null, iOException);
        }
        closing = orig_closing;
    }

    @Override
    public void close() throws Exception {
        closing = true;
        this.closePddlProcess();
        closing = true;
        if (null != this.executor) {
            this.executor.shutdownNow();
            this.executor.awaitTermination(100, TimeUnit.MILLISECONDS);
            this.executor = null;
        }
        if (null != session) {
            session.disconnect();
            session = null;
        }
        jsch = null;
    }
}
