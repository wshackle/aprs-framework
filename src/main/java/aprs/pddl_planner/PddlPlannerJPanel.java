/*
 * This software is public domain software, however it is preferred
 * that the following disclaimers be attached.
 * Software Copyright/Warranty Disclaimer
 * 
 * This software was developed at the National Institute of Standards and
 * Technology by employees of the Federal Government in the course of their
 * official duties. Pursuant to title 17 Section 105 of the United States
 * Code this software is not subject to copyright protection and is in the
 * public domain.
 * 
 * This software is experimental. NIST assumes no responsibility whatsoever 
 * for its use by other parties, and makes no guarantees, expressed or 
 * implied, about its quality, reliability, or any other characteristic. 
 * We would appreciate acknowledgement if the software is used. 
 * This software can be redistributed and/or modified freely provided 
 * that any derivative works bear some notice that they are derived from it, 
 * and any modified versions bear some notice that they have been modified.
 * 
 *  See http://www.copyright.gov/title17/92chap1.html#105
 * 
 */
package aprs.pddl_planner;

import aprs.actions.executor.ExecutorJInternalFrame;
import aprs.system.AprsSystem;
import aprs.actions.executor.Action;
import static aprs.misc.AprsCommonLogger.println;
import aprs.misc.Utils;
import com.jcraft.jsch.Channel;
import com.jcraft.jsch.ChannelExec;
import com.jcraft.jsch.JSch;
import com.jcraft.jsch.JSchException;
import com.jcraft.jsch.Session;
import com.jcraft.jsch.UserInfo;
import crcl.ui.misc.MultiLineStringJPanel;
import java.awt.Desktop;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import org.checkerframework.checker.guieffect.qual.UIEffect;
import org.checkerframework.checker.nullness.qual.MonotonicNonNull;
import org.checkerframework.checker.nullness.qual.Nullable;

/**
 *
 * @author Will Shackleford {@literal <william.shackleford@nist.gov>}
 */
@SuppressWarnings({"unused", "guieffect"})
class PddlPlannerJPanel extends javax.swing.JPanel {

    /**
     * Creates new form PddlPlannerJPanel
     */
    @SuppressWarnings({"nullness","initialization"})
    public PddlPlannerJPanel() {
        initComponents();
        jSpinnerMaxLines.setValue(250);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jLabel1 = new javax.swing.JLabel();
        jTextFieldPlannerProgramExecutable = new javax.swing.JTextField();
        jButtonPlannerProgramExecutableBrowse = new javax.swing.JButton();
        jLabel2 = new javax.swing.JLabel();
        jTextFieldPddlDomainFile = new javax.swing.JTextField();
        jButtonPddlDomainBrowse = new javax.swing.JButton();
        jLabel3 = new javax.swing.JLabel();
        jTextFieldPddlProblem = new javax.swing.JTextField();
        jButtonPddlProblemBrowse = new javax.swing.JButton();
        jLabel4 = new javax.swing.JLabel();
        jTextFieldAdditionalArgs = new javax.swing.JTextField();
        jLabel5 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextAreaOutput = new javax.swing.JTextArea();
        jButtonRunOnce = new javax.swing.JButton();
        jButtonStop = new javax.swing.JButton();
        jButtonPddlDomainEdit = new javax.swing.JButton();
        jButtonPddlProblemEdit = new javax.swing.JButton();
        jCheckBoxSsh = new javax.swing.JCheckBox();
        jLabel6 = new javax.swing.JLabel();
        jTextFieldSshUser = new javax.swing.JTextField();
        jLabel7 = new javax.swing.JLabel();
        jPasswordFieldSshPass = new javax.swing.JPasswordField();
        jLabel8 = new javax.swing.JLabel();
        jTextFieldHost = new javax.swing.JTextField();
        jSpinnerMaxLines = new javax.swing.JSpinner();
        jCheckBoxPauseOutput = new javax.swing.JCheckBox();
        jButtonClear = new javax.swing.JButton();

        jLabel1.setText("Planner Program Executable:");

        jTextFieldPlannerProgramExecutable.setText("popf3-clp");

        jButtonPlannerProgramExecutableBrowse.setText("Browse");
        jButtonPlannerProgramExecutableBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPlannerProgramExecutableBrowseActionPerformed(evt);
            }
        });

        jLabel2.setText("PDDL Domain File");

        jTextFieldPddlDomainFile.setText("domain-kitting.pddl");
        jTextFieldPddlDomainFile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jTextFieldPddlDomainFileActionPerformed(evt);
            }
        });

        jButtonPddlDomainBrowse.setText("Browse");
        jButtonPddlDomainBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlDomainBrowseActionPerformed(evt);
            }
        });

        jLabel3.setText("PDDL Problem File");

        jTextFieldPddlProblem.setText("problem-a2b1c1.pddl");

        jButtonPddlProblemBrowse.setText("Browse");
        jButtonPddlProblemBrowse.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlProblemBrowseActionPerformed(evt);
            }
        });

        jLabel4.setText("Additional Arguments:");

        jTextFieldAdditionalArgs.setText("-I -n");

        jLabel5.setText("Output");

        jTextAreaOutput.setColumns(20);
        jTextAreaOutput.setRows(5);
        jScrollPane1.setViewportView(jTextAreaOutput);

        jButtonRunOnce.setText("Run Once");
        jButtonRunOnce.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonRunOnceActionPerformed(evt);
            }
        });

        jButtonStop.setText("Stop");
        jButtonStop.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonStopActionPerformed(evt);
            }
        });

        jButtonPddlDomainEdit.setText("View/Edit");
        jButtonPddlDomainEdit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlDomainEditActionPerformed(evt);
            }
        });

        jButtonPddlProblemEdit.setText("View/Edit");
        jButtonPddlProblemEdit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonPddlProblemEditActionPerformed(evt);
            }
        });

        jCheckBoxSsh.setText("SSH");
        jCheckBoxSsh.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxSshActionPerformed(evt);
            }
        });

        jLabel6.setText("User:");

        jTextFieldSshUser.setEditable(false);
        jTextFieldSshUser.setText("user");
        jTextFieldSshUser.setEnabled(false);

        jLabel7.setText("Password:");

        jPasswordFieldSshPass.setEditable(false);
        jPasswordFieldSshPass.setText("jPasswordField1");
        jPasswordFieldSshPass.setEnabled(false);

        jLabel8.setText("Host:");

        jTextFieldHost.setEditable(false);
        jTextFieldHost.setText("localhost");
        jTextFieldHost.setEnabled(false);

        jCheckBoxPauseOutput.setText("Pause");

        jButtonClear.setText("Clear");
        jButtonClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButtonClearActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jScrollPane1, javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(jTextFieldAdditionalArgs)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(jTextFieldPddlProblem)
                            .addComponent(jTextFieldPddlDomainFile, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jTextFieldPlannerProgramExecutable))
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                .addGroup(layout.createSequentialGroup()
                                    .addComponent(jButtonPddlProblemBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButtonPddlProblemEdit))
                                .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                    .addComponent(jButtonPddlDomainBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 92, javax.swing.GroupLayout.PREFERRED_SIZE)
                                    .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                                    .addComponent(jButtonPddlDomainEdit)))
                            .addComponent(jButtonPlannerProgramExecutableBrowse, javax.swing.GroupLayout.PREFERRED_SIZE, 179, javax.swing.GroupLayout.PREFERRED_SIZE)))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel5)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jSpinnerMaxLines, javax.swing.GroupLayout.PREFERRED_SIZE, 76, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jCheckBoxPauseOutput)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(jButtonClear)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonStop)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButtonRunOnce))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(jLabel1)
                            .addComponent(jLabel2)
                            .addComponent(jLabel3)
                            .addComponent(jLabel4))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jCheckBoxSsh)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel6)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldSshUser, javax.swing.GroupLayout.DEFAULT_SIZE, 131, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel7)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jPasswordFieldSshPass, javax.swing.GroupLayout.DEFAULT_SIZE, 116, Short.MAX_VALUE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabel8)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jTextFieldHost, javax.swing.GroupLayout.DEFAULT_SIZE, 163, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jLabel1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldPlannerProgramExecutable, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonPlannerProgramExecutableBrowse))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel2)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldPddlDomainFile, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonPddlDomainBrowse)
                    .addComponent(jButtonPddlDomainEdit))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel3)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jTextFieldPddlProblem, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jButtonPddlProblemBrowse)
                    .addComponent(jButtonPddlProblemEdit))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jLabel4)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jTextFieldAdditionalArgs, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jCheckBoxSsh)
                    .addComponent(jLabel6)
                    .addComponent(jTextFieldSshUser, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel8)
                    .addComponent(jTextFieldHost, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel7)
                    .addComponent(jPasswordFieldSshPass, javax.swing.GroupLayout.PREFERRED_SIZE, 27, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jButtonRunOnce)
                    .addComponent(jButtonStop)
                    .addComponent(jLabel5)
                    .addComponent(jSpinnerMaxLines, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jCheckBoxPauseOutput)
                    .addComponent(jButtonClear))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 147, Short.MAX_VALUE)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void browseProgramExecutable() throws IOException {

        JFileChooser chooser = null;
        String curText = jTextFieldPlannerProgramExecutable.getText();
        if (null != curText) {
            File f = new File(curText);
            File parenFile = f.getParentFile();
            if (null != parenFile) {
                chooser = new JFileChooser(parenFile);
            }
        }
        if (null == chooser) {
            chooser = new JFileChooser();
        }
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File f = chooser.getSelectedFile();
            jTextFieldPlannerProgramExecutable.setText(f.getCanonicalPath());
            saveProperties();
        }
    }

    private void browsePddlDomain() throws IOException {
        String domainFileName = jTextFieldPddlDomainFile.getText();
        JFileChooser chooser = new JFileChooser();
        File dir = new File(domainFileName).getParentFile();
        if (null != dir && dir.exists()) {
            chooser.setCurrentDirectory(dir);
        }
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File f = chooser.getSelectedFile();
            jTextFieldPddlDomainFile.setText(f.getCanonicalPath());
            saveProperties();
        }
    }

    private void browsePddlProblem() throws IOException {
        String problemFileName = jTextFieldPddlProblem.getText();
        JFileChooser chooser = new JFileChooser();
        File dir = new File(problemFileName).getParentFile();
        if (null != dir && dir.exists()) {
            chooser.setCurrentDirectory(dir);
        }
        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION) {
            File f = chooser.getSelectedFile();
            jTextFieldPddlProblem.setText(f.getCanonicalPath());
            saveProperties();
        }
    }

    private @MonotonicNonNull
    File propertiesFile = null;

    /**
     * Set the value of propertiesFile
     *
     * @param propertiesFile new value of propertiesFile
     */
    public void setPropertiesFile(File propertiesFile) {
        this.propertiesFile = propertiesFile;
    }

    public void loadProperties() throws IOException {
        if (null == propertiesFile) {
            throw new IllegalStateException("propertiesFile not set");
        }
        if (propertiesFile.exists()) {
            Properties props = new Properties();
            try (FileReader fr = new FileReader(propertiesFile)) {
                props.load(fr);
            }
            String executable = props.getProperty(PROGRAM_EXECUTABLE);
            if (null != executable) {
                jTextFieldPlannerProgramExecutable.setText(executable);
            }
            String domain = props.getProperty(PDDL_DOMAIN);
            if (null != domain) {
                jTextFieldPddlDomainFile.setText(domain);
            }
            String problem = props.getProperty(PDDL_PROBLEM);
            if (null != problem) {
                jTextFieldPddlProblem.setText(problem);
            }
            String useSsh = props.getProperty(PDDL_PLANNER_SSH);
            if (null != useSsh) {
                jCheckBoxSsh.setSelected(Boolean.valueOf(useSsh));
                boolean b = jCheckBoxSsh.isSelected();
                jTextFieldSshUser.setEditable(b);
                jTextFieldSshUser.setEnabled(b);
                jPasswordFieldSshPass.setEditable(b);
                jPasswordFieldSshPass.setEnabled(b);
                jTextFieldHost.setEditable(b);
                jTextFieldHost.setEnabled(b);
            }
            String host = props.getProperty(PDDL_PLANNER_HOST);
            if (null != host) {
                jTextFieldHost.setText(host);
            }
//        String output = props.getProperty(PDDLOUTPUT);
//        if (null != output) {
//            jTextFieldPddlOutputActions.setText(output);
//        }
            String addargs = props.getProperty(PDDL_ADD_ARGS);
            if (null != addargs) {
                jTextFieldAdditionalArgs.setText(addargs);
            }
        }
    }

    private static final String PROGRAM_EXECUTABLE = "program.executable";
    private static final String PDDL_ADD_ARGS = "pddl.addargs";
    private static final String PDDL_PROBLEM = "pddl.problem";
    private static final String PDDL_DOMAIN = "pddl.domain";
    private static final String PDDL_PLANNER_SSH = "pddl.planner.ssh";
    private static final String PDDL_PLANNER_HOST = "pddl.planner.host";

    @UIEffect
    private void jButtonPlannerProgramExecutableBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPlannerProgramExecutableBrowseActionPerformed
        try {
            browseProgramExecutable();
        } catch (IOException ex) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", ex);
        }
    }//GEN-LAST:event_jButtonPlannerProgramExecutableBrowseActionPerformed

    @UIEffect
    private void jTextFieldPddlDomainFileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jTextFieldPddlDomainFileActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_jTextFieldPddlDomainFileActionPerformed

    @UIEffect
    private void jButtonPddlDomainBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlDomainBrowseActionPerformed
        try {
            browsePddlDomain();
        } catch (IOException ex) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", ex);
        }
    }//GEN-LAST:event_jButtonPddlDomainBrowseActionPerformed

    @UIEffect
    private void jButtonPddlProblemBrowseActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlProblemBrowseActionPerformed
        try {
            browsePddlProblem();
        } catch (IOException ex) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", ex);
        }
    }//GEN-LAST:event_jButtonPddlProblemBrowseActionPerformed

    @UIEffect
    private void jButtonRunOnceActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonRunOnceActionPerformed
        try {
            runPddlPlannerOnce();
        } catch (IOException ex) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", ex);
        }
    }//GEN-LAST:event_jButtonRunOnceActionPerformed

    @UIEffect
    private void jButtonStopActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonStopActionPerformed
        this.closePddlProcess();
    }//GEN-LAST:event_jButtonStopActionPerformed

    @UIEffect
    private void jButtonPddlProblemEditActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlProblemEditActionPerformed
        try {
            Desktop.getDesktop().open(new File(jTextFieldPddlProblem.getText()));
        } catch (IOException ex) {
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, "", ex);
        }
    }//GEN-LAST:event_jButtonPddlProblemEditActionPerformed

    @UIEffect
    private void jButtonPddlDomainEditActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonPddlDomainEditActionPerformed
        try {
            Desktop.getDesktop().open(new File(jTextFieldPddlDomainFile.getText()));
        } catch (IOException ex) {
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, "", ex);
        }
    }//GEN-LAST:event_jButtonPddlDomainEditActionPerformed

    @UIEffect
    private void jCheckBoxSshActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxSshActionPerformed
        boolean useSsh = jCheckBoxSsh.isSelected();
        jTextFieldSshUser.setEditable(useSsh);
        jTextFieldSshUser.setEnabled(useSsh);
        jPasswordFieldSshPass.setEditable(useSsh);
        jPasswordFieldSshPass.setEnabled(useSsh);
        jTextFieldHost.setEditable(useSsh);
        jTextFieldHost.setEnabled(useSsh);
    }//GEN-LAST:event_jCheckBoxSshActionPerformed

    @UIEffect
    private void jButtonClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButtonClearActionPerformed
        jTextAreaOutput.setText("");
    }//GEN-LAST:event_jButtonClearActionPerformed

    private ExecutorService executor = Executors.newCachedThreadPool();

    /**
     * Get the value of executor
     *
     * @return the value of executor
     */
    public ExecutorService getExecutor() {
        return executor;
    }

    /**
     * Set the value of executor
     *
     * @param executor new value of executor
     */
    public void setExecutor(ExecutorService executor) {
        this.executor = executor;
    }

    private @Nullable
    ExecutorJInternalFrame actionsToCrclJInternalFrame1 = null;

    public @Nullable
    ExecutorJInternalFrame getActionsToCrclJInternalFrame1() {
        return actionsToCrclJInternalFrame1;
    }

    public void setActionsToCrclJInternalFrame1(@Nullable ExecutorJInternalFrame actionsToCrclJInternalFrame1) {
        this.actionsToCrclJInternalFrame1 = actionsToCrclJInternalFrame1;
    }

    public List<Action> getActionsList() {
        if (null == actionsToCrclJInternalFrame1) {
            throw new RuntimeException("null == actionsToCrclJInternalFrame1");
        }
        return actionsToCrclJInternalFrame1.getActionsList();
    }

    private void addAction(Action action) {
        if (null != actionsToCrclJInternalFrame1) {
            this.actionsToCrclJInternalFrame1.addAction(action);
        }
    }

    private void processActions() {
        if (null != actionsToCrclJInternalFrame1) {
            this.actionsToCrclJInternalFrame1.processActions();
        }
    }

    private @Nullable
    Process pddlProcess = null;
    private @Nullable
    InputStream pddlInputStream = null;
    private @Nullable
    InputStream pddlErrorStream = null;
    private @Nullable
    Future<?> ppdlInputStreamFuture = null;
    private @Nullable
    Future<?> ppdlErrorStreamFuture = null;

    @SuppressWarnings("nullness")
    private final UserInfo sshUserInfo = new UserInfo() {

        @Override
        public String getPassphrase() {
            return null;
        }

        @Override
        public String getPassword() {
            String p = new String(jPasswordFieldSshPass.getPassword());
            return p;
        }

        @Override
        public boolean promptPassword(String string) {
            return true;
        }

        @Override
        public boolean promptPassphrase(String string) {
            return false;
        }

        @Override
        public boolean promptYesNo(String string) {
            println(string);
            return JOptionPane.showConfirmDialog(PddlPlannerJPanel.this, string) == JOptionPane.YES_OPTION;
        }

        @Override
        public void showMessage(String string) {
            println(string);
            MultiLineStringJPanel.showText(string);
        }
    };

    @SuppressWarnings("nullness")
    private void sshExec(Session session, String command) throws JSchException, IOException, InterruptedException, ExecutionException {
        printMessage("Excuting remote command \"" + command + "\" ...");
        Channel channel = session.openChannel("exec");
        ((ChannelExec) channel).setCommand(command);
        channel.setInputStream(null);
        ((ChannelExec) channel).setErrStream(System.err);

        InputStream in = channel.getInputStream();

        channel.connect();

        pddlInputStream = in;
        pddlErrorStream = null;
        setupOutputHandlers();
        if (null != ppdlInputStreamFuture) {
            ppdlInputStreamFuture.get();
        }
        channel.disconnect();
        printMessage("Finished remote command \"" + command + "\".");
    }

    private boolean lastMessageBlank = false;

    private final List<String> logLines = new ArrayList<>();

    private void appendLine(String l) {
        int maxLines = 100;
        try {
            maxLines = (int) jSpinnerMaxLines.getValue();
            if (maxLines < 1) {
                jSpinnerMaxLines.setValue(1);
                maxLines = 1;
            }
        } catch (Exception exception) {
            Logger.getLogger(PddlPlannerJPanel.class
                    .getName()).log(Level.SEVERE, "", exception);
        }
        if (logLines.size() < maxLines) {
            addLogLine(l);
            if (!jCheckBoxPauseOutput.isSelected()) {
                jTextAreaOutput.append(l);
            }
        } else {
            while (logLines.size() >= maxLines) {
                logLines.remove(0);
            }
            addLogLine(l);
            StringBuilder sb = new StringBuilder();
            for (String logLine : logLines) {
                sb.append(logLine);
            }
            if (!jCheckBoxPauseOutput.isSelected()) {
                jTextAreaOutput.setText(sb.toString());
            }
        }
        if (!jCheckBoxPauseOutput.isSelected()) {
            jTextAreaOutput.setCaretPosition(jTextAreaOutput.getText().length() - 1);
        }
    }

    private void addLogLine(String l) {
        if (logLines.size() > 0) {
            String lastLine = logLines.get(logLines.size() - 1);
            if (lastLine.endsWith("\n")) {
                logLines.add(l);
            } else {
                logLines.set(logLines.size() - 1, lastLine + l);
            }
        } else {
            logLines.add(l);
        }
    }

    private void appendText(String text) {
        String txt2 = text.replace("\r\n", "\n");
        String lines[] = txt2.split("\n");
        if (lines.length <= 1 || (lines.length == 2) && lines[1].length() < 1) {
            appendLine(txt2);
        } else {
            for (int i = 0; i < lines.length; i++) {
                String line = lines[i];
                if (i < lines.length - 1 || txt2.endsWith("\n")) {
                    appendLine(line + System.lineSeparator());
                } else {
                    appendLine(line);
                }
            }
        }
    }

    private void printMessage(String msg) {
        boolean msgIsBlank = msg.trim().length() < 1;
        if (!msgIsBlank || !lastMessageBlank) {
            println(msg);
            appendText(msg);
        }
        lastMessageBlank = msgIsBlank;
    }

    private void scp(Session session, String host, String rfile, String lfile) throws Exception {
        FileInputStream fis = null;
        printMessage("Copying local file \"" + lfile + "\" to remote host " + host + " as remote file \"" + rfile + "\" ...");
        boolean ptimestamp = false;
        // exec 'scp -t rfile' remotely
        String command = "scp " + (ptimestamp ? "-p" : "") + " -t " + rfile;
        Channel channel = session.openChannel("exec");
        ((ChannelExec) channel).setCommand(command);
        // get I/O streams for remote scp
        OutputStream out = channel.getOutputStream();
        InputStream in = channel.getInputStream();
        channel.connect();
        if (checkAck(in) != 0) {
            System.exit(0);
        }
        File _lfile = new File(lfile);
        if (ptimestamp) {
            command = "T " + (_lfile.lastModified() / 1000) + " 0";
            // The access time should be sent here,
            // but it is not accessible with JavaAPI ;-<
            command += (" " + (_lfile.lastModified() / 1000) + " 0\n");
            out.write(command.getBytes());
            out.flush();
            if (checkAck(in) != 0) {
                System.exit(0);
            }
        }
        // send "C0644 filesize filename", where filename should not include '/'
        long filesize = _lfile.length();
        command = "C0644 " + filesize + " ";
        if (lfile.lastIndexOf('/') > 0) {
            command += lfile.substring(lfile.lastIndexOf('/') + 1);
        } else {
            command += lfile;
        }
        command += "\n";
        out.write(command.getBytes());
        out.flush();
        if (checkAck(in) != 0) {
            System.exit(0);
        }
        // send a content of lfile
        fis = new FileInputStream(lfile);
        byte[] buf = new byte[1024];
        while (true) {
            int len = fis.read(buf, 0, buf.length);
            if (len <= 0) {
                break;
            }
            out.write(buf, 0, len); //out.flush();
        }
        fis.close();
        fis = null;
        // send '\0'
        buf[0] = 0;
        out.write(buf, 0, 1);
        out.flush();
        if (checkAck(in) != 0) {
            System.exit(0);
        }
        out.close();
        channel.disconnect();
        printMessage("Finished copy of local file \"" + lfile + "\" to remote host " + host + " as remote file \"" + rfile + "\".");
    }

    private static int checkAck(InputStream in) throws Exception {
        int b = in.read();
        // b may be 0 for success,
        //          1 for error,
        //          2 for fatal error,
        //          -1
        if (b == 0) {
            return b;
        }
        if (b == -1) {
            throw new Exception("Ssh checkAck() returned: " + b);
        }

        if (b == 1 || b == 2) {
            StringBuilder sb = new StringBuilder();
            int c;
            do {
                c = in.read();
                sb.append((char) c);
            } while (c != '\n');
            if (b == 1) { // error
                System.out.print(sb.toString());
                throw new Exception("Ssh checkAck() returned  error code. b=" + b);
            }
            if (b == 2) { // fatal error
                System.out.print(sb.toString());
                throw new Exception("Ssh checkAck() returned fatal error code. b=" + b);
            }
        }
        return b;
    }

    private @Nullable
    JSch jsch = null;
    private @Nullable
    Session session = null;

    private void runPddlPlannerOnceSsh() {
        try {
            JSch jsch = this.jsch;
            if (null == jsch) {
                jsch = new JSch();
                this.jsch = jsch;
            }
            String host = jTextFieldHost.getText();
            Session currentSession = this.session;
            if (null == currentSession) {
                currentSession = jsch.getSession(jTextFieldSshUser.getText(), jTextFieldHost.getText(), 22);
                currentSession.setUserInfo(sshUserInfo);
                currentSession.connect();
                this.session = currentSession;
            }
            Session pddlPlannerSession = currentSession;
            long t = System.currentTimeMillis();
            String remoteDomainFile = "/tmp/domain_" + t + ".pddl";
            String remoteProblemFile = "/tmp/problem_" + t + ".pddl";
            scp(pddlPlannerSession, host, remoteDomainFile, jTextFieldPddlDomainFile.getText());
            scp(pddlPlannerSession, host, remoteProblemFile, jTextFieldPddlProblem.getText());
            sshExec(pddlPlannerSession, jTextFieldPlannerProgramExecutable.getText() + " " + jTextFieldAdditionalArgs.getText() + " " + remoteDomainFile + " " + remoteProblemFile);
        } catch (Exception ex) {
            printMessage("runPddlPlannerOnceSsh failed with " + ex);
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, "", ex);
        }
    }

    private void clearActionsList() {
        if (null != actionsToCrclJInternalFrame1) {
            actionsToCrclJInternalFrame1.warnIfNewActionsNotReady();
            actionsToCrclJInternalFrame1.clearActionsList();
        }
    }

    private void runPddlPlannerOnce() throws IOException {

        clearActionsList();
        if (this.jCheckBoxSsh.isSelected()) {
            runPddlPlannerOnceSsh();
            return;
        }
        try {
            closePddlProcess();
        } catch (Exception ex) {
            Logger.getLogger(PddlPlannerJPanel.class.getName()).log(Level.SEVERE, "", ex);
        }
        List<String> commandList = new ArrayList<>();
        commandList.add(new File(jTextFieldPlannerProgramExecutable.getText()).getCanonicalPath());
        commandList.addAll(Arrays.asList(jTextFieldAdditionalArgs.getText().split("[ \t]+")));
        commandList.add(jTextFieldPddlDomainFile.getText());
        commandList.add(jTextFieldPddlProblem.getText());
        ProcessBuilder pb = new ProcessBuilder(commandList);
        pddlProcess = pb.start();
        pddlInputStream = pddlProcess.getInputStream();
        pddlErrorStream = pddlProcess.getErrorStream();
        jTextAreaOutput.append(commandList.toString() + System.lineSeparator());
        setupOutputHandlers();
    }

    private void setupOutputHandlers() {
        if (null == executor) {
            executor = Executors.newCachedThreadPool();
        }
        if (null != pddlErrorStream) {
            ppdlErrorStreamFuture = executor.submit(new Runnable() {
                @Override
                public void run() {
                    if (null != pddlErrorStream) {
                        try (BufferedReader br = new BufferedReader(new InputStreamReader(pddlErrorStream))) {
                            String line = null;
                            while (null != (line = br.readLine()) && !closing && !Thread.currentThread().isInterrupted()) {
                                final String lineToAppend = line;
                                println("Line from remote error source:" + line);
                                javax.swing.SwingUtilities.invokeLater(new Runnable() {
                                    @Override
                                    public void run() {
                                        printMessage(lineToAppend + System.lineSeparator());
                                    }
                                });
                            }
                        } catch (IOException ex) {
                            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", ex);
                        }
                    }
                }
            });
        }
        if (null == pddlInputStream) {
            throw new IllegalStateException("pddlInputStream is null");
        }
        ppdlInputStreamFuture = executor.submit(this::readPddlInputStream);
    }

    private void readPddlInputStream() throws IllegalStateException {
        if (null == pddlInputStream) {
            throw new IllegalStateException("pddlInputStream is null");
        }
        try (BufferedReader br = new BufferedReader(new InputStreamReader(pddlInputStream))) {
            String line = null;
            boolean planFoundFound = false;
            while (null != (line = br.readLine()) && !closing && !Thread.currentThread().isInterrupted()) {
                final String lineToAppend = line;
                println("Line from remote out source:" + line);
                javax.swing.SwingUtilities.invokeLater(new Runnable() {
                    @Override
                    public void run() {
                        printMessage(lineToAppend + System.lineSeparator());
                    }
                });

                if (planFoundFound) {
                    addAction(Action.parse(lineToAppend));
                }
                if (line.contains("; Plan found") || line.contains("Solution Found")) {
                    planFoundFound = true;
                }
            }
            ExecutorJInternalFrame executor = actionsToCrclJInternalFrame1;
            if (null != executor) {
                Utils.runOnDispatchThread(() -> {
                    if (null != executor) {
                        executor.autoResizeTableColWidthsPddlOutput();
                    }
                });
                executor.autoResizeTableColWidthsPddlOutput();
            }
            processActions();
        } catch (IOException ex) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", ex);
        }
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonClear;
    private javax.swing.JButton jButtonPddlDomainBrowse;
    private javax.swing.JButton jButtonPddlDomainEdit;
    private javax.swing.JButton jButtonPddlProblemBrowse;
    private javax.swing.JButton jButtonPddlProblemEdit;
    private javax.swing.JButton jButtonPlannerProgramExecutableBrowse;
    private javax.swing.JButton jButtonRunOnce;
    private javax.swing.JButton jButtonStop;
    private javax.swing.JCheckBox jCheckBoxPauseOutput;
    private javax.swing.JCheckBox jCheckBoxSsh;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JPasswordField jPasswordFieldSshPass;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSpinner jSpinnerMaxLines;
    private javax.swing.JTextArea jTextAreaOutput;
    private javax.swing.JTextField jTextFieldAdditionalArgs;
    private javax.swing.JTextField jTextFieldHost;
    private javax.swing.JTextField jTextFieldPddlDomainFile;
    private javax.swing.JTextField jTextFieldPddlProblem;
    private javax.swing.JTextField jTextFieldPlannerProgramExecutable;
    private javax.swing.JTextField jTextFieldSshUser;
    // End of variables declaration//GEN-END:variables

    public void saveProperties() {
        if (null == propertiesFile) {
            throw new IllegalStateException("propertiesFile not set");
        }
        File parentFile = propertiesFile.getParentFile();
        if (null == parentFile) {
            throw new IllegalStateException("propertiesFile=" + propertiesFile + " has no parent");
        }
        parentFile.mkdirs();
        Map<String, String> propsMap = new HashMap<>();
        propsMap.put(PROGRAM_EXECUTABLE, jTextFieldPlannerProgramExecutable.getText());
        propsMap.put(PDDL_DOMAIN, jTextFieldPddlDomainFile.getText());
        propsMap.put(PDDL_PROBLEM, jTextFieldPddlProblem.getText());
//        propsMap.put(PDDLOUTPUT, jTextFieldPddlOutputActions.getText());
        propsMap.put(PDDL_ADD_ARGS, jTextFieldAdditionalArgs.getText());
        propsMap.put(PDDL_PLANNER_SSH, Boolean.toString(jCheckBoxSsh.isSelected()));
        propsMap.put(PDDL_PLANNER_HOST, jTextFieldHost.getText());
        Properties props = new Properties();
        props.putAll(propsMap);
//        try (FileWriter fw = new FileWriter(propertiesFile)) {
//            props.store(fw, "");
//        }
        Utils.saveProperties(propertiesFile, props);
    }

    private volatile boolean closing = false;

    private void closePddlProcess() {
        boolean orig_closing = closing;
        closing = true;
        try {
            if (null != pddlProcess) {
                pddlProcess.destroyForcibly().waitFor(100, TimeUnit.MILLISECONDS);
                pddlProcess = null;
            }
        } catch (InterruptedException interruptedException) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", interruptedException);
        }
        try {
            if (null != ppdlInputStreamFuture) {
                ppdlInputStreamFuture.cancel(true);
                ppdlInputStreamFuture = null;
            }
        } catch (Exception e) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", e);
        }
        try {
            if (null != ppdlErrorStreamFuture) {
                ppdlErrorStreamFuture.cancel(true);
                ppdlErrorStreamFuture = null;
            }
        } catch (Exception e) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", e);
        }
        try {
            if (null != pddlInputStream) {
                pddlInputStream.close();
                pddlInputStream = null;
            }
        } catch (IOException iOException) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", iOException);
        }
        try {
            if (null != pddlErrorStream) {
                pddlErrorStream.close();
                pddlErrorStream = null;
            }
        } catch (IOException iOException) {
            Logger.getLogger(AprsSystem.class.getName()).log(Level.SEVERE, "", iOException);
        }
        closing = orig_closing;
    }

    public void close() {
        closing = true;
        this.closePddlProcess();
        closing = true;
        ExecutorService executorToShutdown = this.executor;
        if (null != executorToShutdown) {
            executorToShutdown.shutdownNow();
//            this.executor.awaitTermination(100, TimeUnit.MILLISECONDS);
        }
        if (null != session) {
            session.disconnect();
            session = null;
        }
        jsch = null;
    }

    public @Nullable
    File getPropertiesFile() {
        return propertiesFile;
    }
}
